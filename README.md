---
marp: true
---

[《数据结构与算法》 邓俊辉 清华MOOC](https://www.bilibili.com/video/av49361421?p=1)
***
# [P1 计算](https://www.bilibili.com/video/av49361421?p=1)
**算法具有以下要求**
>==输入、输出、正确性、确定性、可行性、有穷性==

# [P2 算法有穷性](https://www.bilibili.com/video/av49361421?p=2)
```math
序列Hailstone=
\begin{cases}
	{1}&		n\leq1\\
	{n} \cup Hailstone(\frac{n}{2}) &		n偶\\
    {n} \cup Hailstone(3n+1) &  n奇\\
\end{cases}
\\
```
$$例：Hailstone(42) = \{42, 21, 64, 32, \cdots, 1\}$$
```c
int hailstone(int n)
int length = 1;
while (1 < n){(n % 2) ? n = 3 * n + 1 : n /= 2; length++;}
return length;
```
**问：对于任意的$n$，总有$|Hailstone(n)|<\infty？$**
这个问题没有答案，所以上面的程序不是算法。

# [P3 好算法](https://www.bilibili.com/video/av49361421?p=3)
>正确、健壮、==可读==、效率。

# [P4 计算模型](https://www.bilibili.com/video/av49361421?p=4)
令$T_A(n)=$用算法A求解某一问题规模为$n$的实例，所需计算成本
稳妥起见，取
$$T(n)=max\{T(P) \big| |P|=n\}$$
亦即，在规模同为$n$的所有实例中，只关注最坏（成本最高）者。
# [P5 图灵机](https://www.bilibili.com/video/av49361421?p=5)
想要评价一个算法的优劣，需要找到不受不同规模、不同类型输入，不同程序员，不同语言，不同编译器，不同体系结构、操作系统……影响的评判方法。
* Tape 依次均匀的划分为单元格，各注有某一字符，默认为‘#’
* Alphabet 字符种类有限
* Head 总是对准某一单元格，并可以读取和改写其最终的字符，每经过一个节拍，可转向左侧或右侧的邻格
* TM总是出于有限种状态中的一种，每经过一个接排，可按照规则转向另一种状态。
![图灵机](https://i.imgur.com/sq3Wv5h.jpg)
Transition Function：(q,c;d,L/R,p)
若当前状态为q且当前字符为c，则将当前字符==改写==为d；==转向==左侧/右侧的邻格；==转入==p状态，一旦转入特定状态'h'，则停机。
**将二进制非负数加一**
`# # # 0 1 1 1 1`<--~^~ `# #`
算法：全1的后最翻转为全0，原最低位的0或#翻转为1
(<, 1, 0, L, <) //左行，1-->0
(<, 0, 1, R, >) //掉头，0-->1
(<, #, 1, R, >) //进位之后往右
(>, 0, 0, R, >) // 右行
(>, #, #, L, h) // 复位 ==有必要==
# [P6 RAM](https://www.bilibili.com/video/av49361421?p=6)
与图灵机一样，RAM模型也是一般计算工具的简化与抽象
**算法运行时间 $\varpropto$ 算法需要执行的基本操作次数**
$T(N)$= 算法为求解规模为n的问题所需基本操作次数。
# [P7 大 $O$](https://www.bilibili.com/video/av49361421?p=7)
问：随着问题的规模的增长，计算成本如何增长？

**问题规模**：问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般一般用整数$n$表示。
矩阵运算|排序运算|多项式运算|集合运算|树运算|图运算
---|---|---|---|---|---
n为矩阵阶数|n为参加排序记录数|n为多项式项数|元素个数|节点数|顶点数或边数
**语句频度**：一条语句重复执行次数。

分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模$n$的某个函数$f(n)$，取其数量级用符号$O$表示即可。

>**定理 1.1** 若$f(n)=a_m n^m + a_{m-1} n^{m-1}+ \cdots +a_1n + a_0$是一个$m$次多项式，则$T(n)=O(n^m)$.

若算法课用递归方法描述，则算法的时间复杂度通常可使用递归方程表示。

**【例 1.9】**
```c {.line-numbers}
for (i = 1; i <= n; i = i*2) {x++; s=0;}
```
设循环体内两条基本语句的频度$f(n)$,则有$2^{f(n)}\leqslant n$，$f(n)\leqslant\log_2n$，所以算法时间复杂度为$T(n)=O(\log_2n)$，称为对数阶。

**算法的空间复杂度**
采用渐近空间复杂度作为算法所需存储空间的量度，它也是问题规模$n$的函数，记作：
$$S(n)=O(f(n))$$
下面举几个例子说明算法空间复杂度。
>**【例1.11】** 数组逆序，将一维数组$a$中的$n$个数逆序存放到原数组中。
```c {.line-numbers}
//算法1
for (int i = 0; i < n / 2; i++)
{
    t = a[i];
    a[i] = a[n - i - 1];
    a[n - i - 1] = t;
}

//算法2
for (int i = 0; i < n; i++)
{
    b[i] = a[n - i - 1];
}
for (int i = 0; i < n; i++)
{
    a[i] = b[i];
}
```
算法1仅需要另外借助一个变量t，与问题规模$n$大小无关，所以其空间复杂度为$O(1)$
算法2需要另外接著一个大小为$n$的辅助数组b，所以其空间复杂度为$O(n)$。

* 对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂度时，==可能==会导致占用较多的存储空间，即可能会使空间复杂度的性能变差，反之亦然。
* 不过通常情况下，鉴于运算空间较为充足，人们都更最求算法的时间复杂度。
